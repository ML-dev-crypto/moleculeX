"""
Semantic search powered by Google Gemini API
"""
import os
import json
import time
from typing import List, Dict, Any, Tuple
import google.generativeai as genai


class SemanticSearchEngine:
    """AI-powered semantic search using Gemini"""
    
    def __init__(self):
        api_key = os.getenv("GEMINI_API_KEY")
        if api_key:
            genai.configure(api_key=api_key)
            self.model = genai.GenerativeModel('gemini-2.0-flash-exp')
            self.last_call_time = 0
            self.min_call_interval = 1.0  # Minimum 1 second between calls
            print("✅ Semantic search initialized (Gemini-powered)")
            self.use_ai = True
        else:
            print("⚠️ GEMINI_API_KEY not found, using basic mode")
            self.use_ai = False
    
    def _rate_limit(self):
        """Ensure minimum time between API calls"""
        if self.use_ai:
            elapsed = time.time() - self.last_call_time
            if elapsed < self.min_call_interval:
                time.sleep(self.min_call_interval - elapsed)
            self.last_call_time = time.time()
    
    def re_rank_clinical_trials(self, query: str, trials: List[Any]) -> List[Any]:
        """Re-rank clinical trials using Gemini AI"""
        if not self.use_ai or not trials:
            return trials
        
        try:
            # Create a lightweight representation for ranking
            trial_summaries = []
            for i, trial in enumerate(trials[:20]):  # Limit to top 20 to reduce tokens
                summary = {
                    "index": i,
                    "title": getattr(trial, 'title', 'N/A')[:200],
                    "status": getattr(trial, 'status', 'N/A'),
                    "phase": getattr(trial, 'phase', 'N/A')
                }
                trial_summaries.append(summary)
            
            prompt = f"""You are a pharmaceutical research analyst. Given this query: "{query}"

Rank the following clinical trials by relevance (most relevant first). Consider:
- Title relevance to the query
- Study status (RECRUITING > ACTIVE > COMPLETED)
- Trial phase (higher phase = more advanced)

Clinical Trials:
{json.dumps(trial_summaries, indent=2)}

Return ONLY a JSON array of indices in order of relevance, like: [2, 0, 5, 1, ...]"""

            self._rate_limit()  # Rate limit protection
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )
            ranked_indices = json.loads(response.text.strip())
            
            # Reorder trials based on AI ranking
            ranked_trials = [trials[i] for i in ranked_indices if i < len(trials)]
            # Add any remaining trials not ranked
            remaining = [t for i, t in enumerate(trials) if i not in ranked_indices]
            return ranked_trials + remaining
            
        except Exception as e:
            print(f"⚠️ Gemini re-ranking failed: {e}, using original order")
            return trials
    
    def re_rank_patents(self, query: str, patents: List[Any]) -> List[Any]:
        """Re-rank patents using Gemini AI"""
        if not self.use_ai or not patents:
            return patents
        
        try:
            patent_summaries = []
            for i, patent in enumerate(patents[:20]):
                summary = {
                    "index": i,
                    "title": getattr(patent, 'title', 'N/A')[:200],
                    "assignee": getattr(patent, 'assignee', 'N/A')[:100]
                }
                patent_summaries.append(summary)
            
            prompt = f"""You are a pharmaceutical patent analyst. Given this query: "{query}"

Rank the following patents by relevance (most relevant first). Consider:
- Title relevance to the query
- Assignee reputation (major pharma companies ranked higher)

Patents:
{json.dumps(patent_summaries, indent=2)}

Return ONLY a JSON array of indices in order of relevance, like: [1, 3, 0, 2, ...]"""

            self._rate_limit()  # Rate limit protection
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )
            ranked_indices = json.loads(response.text.strip())
            
            ranked_patents = [patents[i] for i in ranked_indices if i < len(patents)]
            remaining = [p for i, p in enumerate(patents) if i not in ranked_indices]
            return ranked_patents + remaining
            
        except Exception as e:
            print(f"⚠️ Gemini re-ranking failed: {e}, using original order")
            return patents
    
    def re_rank_literature(self, query: str, literature: List[Any]) -> List[Any]:
        """Re-rank literature using Gemini AI"""
        if not self.use_ai or not literature:
            return literature
        
        try:
            lit_summaries = []
            for i, paper in enumerate(literature[:20]):
                summary = {
                    "index": i,
                    "title": getattr(paper, 'title', 'N/A')[:200],
                    "source": getattr(paper, 'source', 'N/A')
                }
                lit_summaries.append(summary)
            
            prompt = f"""You are a scientific literature analyst. Given this query: "{query}"

Rank the following research papers by relevance (most relevant first). Consider:
- Title relevance to the query
- Source credibility (peer-reviewed journals ranked higher)

Papers:
{json.dumps(lit_summaries, indent=2)}

Return ONLY a JSON array of indices in order of relevance, like: [4, 1, 0, 3, ...]"""

            self._rate_limit()  # Rate limit protection
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )
            ranked_indices = json.loads(response.text.strip())
            
            ranked_lit = [literature[i] for i in ranked_indices if i < len(literature)]
            remaining = [l for i, l in enumerate(literature) if i not in ranked_indices]
            return ranked_lit + remaining
            
        except Exception as e:
            print(f"⚠️ Gemini re-ranking failed: {e}, using original order")
            return literature
    
    def compute_confidence_score(
        self, 
        query: str,
        clinical_trials: List[Any],
        patents: List[Any],
        web_intel: List[Any]
    ) -> Tuple[float, str]:
        """Compute confidence score with AI enhancement"""
        total = len(clinical_trials) + len(patents) + len(web_intel)
        
        # Base score on quantity
        if total >= 20:
            base_score = 0.85
        elif total >= 10:
            base_score = 0.70
        else:
            base_score = 0.50
        
        # If AI is available, ask for quality assessment
        if self.use_ai and total > 0:
            try:
                prompt = f"""Assess data quality for query: "{query}"

Data found:
- {len(clinical_trials)} clinical trials
- {len(patents)} patents  
- {len(web_intel)} publications

On a scale of 0.0-1.0, how relevant and comprehensive is this data? Return ONLY a number."""

                self._rate_limit()  # Rate limit protection
                response = self.client.models.generate_content(
                    model=self.model,
                    contents=prompt
                )
                ai_score = float(response.text.strip())
                # Blend base score with AI score
                final_score = (base_score + ai_score) / 2
                
                if final_score >= 0.75:
                    return round(final_score, 2), "High"
                elif final_score >= 0.55:
                    return round(final_score, 2), "Medium"
                else:
                    return round(final_score, 2), "Low"
            except:
                pass
        
        # Fallback to count-based
        return base_score, "High" if base_score >= 0.75 else "Medium" if base_score >= 0.55 else "Low"
